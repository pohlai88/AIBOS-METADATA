// metadata-studio/db/schema/naming-policy.tables.ts

import {
  pgTable,
  uuid,
  text,
  boolean,
  timestamp,
  jsonb,
  uniqueIndex,
  index,
} from 'drizzle-orm/pg-core';

/**
 * mdm_naming_policy
 * 
 * GRCD Phase 2: Naming Policy Enforcement
 * 
 * Defines rules for naming conventions across different contexts:
 * - Pattern validation (regex)
 * - Reserved words
 * - Prefix/suffix requirements by domain
 * - Case enforcement by context
 * 
 * Example policies:
 * - "db_column_pattern": /^[a-z][a-z0-9]*(_[a-z0-9]+)*$/ (snake_case)
 * - "typescript_pattern": /^[a-z][a-zA-Z0-9]*$/ (camelCase)
 * - "reserved_words": ["system", "admin", "test", "null"]
 */
export const mdmNamingPolicy = pgTable(
  'mdm_naming_policy',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    tenantId: uuid('tenant_id').notNull(),
    
    // Policy identifier
    policyKey: text('policy_key').notNull(), // e.g., "db_column", "typescript_field", "api_endpoint"
    
    // Human-readable
    label: text('label').notNull(),
    description: text('description'),
    
    // What this policy applies to
    appliesTo: text('applies_to')
      .$type<'canonical_key' | 'db_column' | 'typescript' | 'api_path' | 'graphql' | 'const'>()
      .notNull(),
    
    // Domain scope (optional - null means applies to all)
    domain: text('domain'),
    
    // Validation rules (JSON)
    rules: jsonb('rules').$type<NamingPolicyRules>().notNull(),
    
    // Governance
    tier: text('tier')
      .$type<'tier1' | 'tier2' | 'tier3' | 'tier4' | 'tier5'>()
      .notNull()
      .default('tier2'),
    
    // Enforcement level
    enforcement: text('enforcement')
      .$type<'error' | 'warning' | 'info'>()
      .notNull()
      .default('error'),
    
    // Active status
    isActive: boolean('is_active').notNull().default(true),
    
    // Audit
    createdBy: text('created_by').notNull(),
    updatedBy: text('updated_by').notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => ({
    tenantPolicyKeyUnique: uniqueIndex('mdm_naming_policy_tenant_key_idx').on(
      table.tenantId,
      table.policyKey,
    ),
    appliesToIdx: index('mdm_naming_policy_applies_to_idx').on(table.appliesTo),
    domainIdx: index('mdm_naming_policy_domain_idx').on(table.domain),
  }),
);

/**
 * Naming policy rules structure
 */
export interface NamingPolicyRules {
  // Regex pattern for validation
  pattern?: string;
  patternDescription?: string;
  
  // Min/max length
  minLength?: number;
  maxLength?: number;
  
  // Required prefix/suffix
  requiredPrefix?: string;
  requiredSuffix?: string;
  
  // Forbidden patterns
  forbiddenPatterns?: string[];
  
  // Reserved words (cannot use these)
  reservedWords?: string[];
  
  // Required words (must include one of these)
  requiredWords?: string[];
  
  // Case requirement
  caseStyle?: 'snake_case' | 'camelCase' | 'PascalCase' | 'UPPER_SNAKE' | 'kebab-case';
}

export type NamingPolicy = typeof mdmNamingPolicy.$inferSelect;
export type InsertNamingPolicy = typeof mdmNamingPolicy.$inferInsert;

/**
 * mdm_agent_proposal
 * 
 * GRCD Phase 2: AI Agent Proposals
 * 
 * Tracks proposals generated by AI agents that require human review.
 * Extends the approval workflow with AI-specific metadata.
 */
export const mdmAgentProposal = pgTable(
  'mdm_agent_proposal',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    tenantId: uuid('tenant_id').notNull(),
    
    // Link to approval request
    approvalId: uuid('approval_id').notNull(),
    
    // Agent info
    agentType: text('agent_type')
      .$type<'data_quality_sentinel' | 'schema_drift_detector' | 'lineage_analyzer' | 'naming_validator'>()
      .notNull(),
    agentVersion: text('agent_version').notNull(),
    
    // Confidence and reasoning
    confidence: text('confidence').$type<'high' | 'medium' | 'low'>().notNull(),
    confidenceScore: text('confidence_score'), // 0-100
    reasoning: text('reasoning').notNull(),
    
    // Evidence/context that led to proposal
    evidence: jsonb('evidence').$type<AgentEvidence>().notNull(),
    
    // Risk assessment
    riskLevel: text('risk_level')
      .$type<'critical' | 'high' | 'medium' | 'low' | 'minimal'>()
      .notNull(),
    potentialImpact: text('potential_impact'),
    
    // Suggested actions
    suggestedAction: text('suggested_action')
      .$type<'create' | 'update' | 'delete' | 'flag' | 'investigate'>()
      .notNull(),
    alternativeActions: jsonb('alternative_actions').$type<string[]>(),
    
    // Human feedback (after review)
    humanFeedback: text('human_feedback'),
    wasHelpful: boolean('was_helpful'),
    
    // Timestamps
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    reviewedAt: timestamp('reviewed_at', { withTimezone: true }),
  },
  (table) => ({
    approvalIdx: index('mdm_agent_proposal_approval_idx').on(table.approvalId),
    agentTypeIdx: index('mdm_agent_proposal_agent_type_idx').on(table.agentType),
    confidenceIdx: index('mdm_agent_proposal_confidence_idx').on(table.confidence),
    riskLevelIdx: index('mdm_agent_proposal_risk_level_idx').on(table.riskLevel),
  }),
);

/**
 * Evidence structure for agent proposals
 */
export interface AgentEvidence {
  // What triggered the proposal
  trigger: string;
  
  // Data points that support the proposal
  dataPoints: Array<{
    source: string;
    value: string | number | boolean;
    timestamp?: string;
  }>;
  
  // Related entities
  relatedEntities?: Array<{
    entityType: string;
    entityId: string;
    relationship: string;
  }>;
  
  // Source references
  sourceReferences?: string[];
}

export type AgentProposal = typeof mdmAgentProposal.$inferSelect;
export type InsertAgentProposal = typeof mdmAgentProposal.$inferInsert;

