// metadata-studio/services/agent-proposal.service.ts

/**
 * Agent Proposal Service
 * 
 * GRCD Phase 2: AI Agent Proposal Management
 * 
 * Handles proposals generated by AI agents that require human review.
 * Integrates with the approval workflow to track AI-specific metadata.
 */

import { db } from '../db/client';
import { mdmAgentProposal, type AgentEvidence } from '../db/schema/naming-policy.tables';
import { mdmApproval } from '../db/schema/approval.tables';
import { approvalService } from './approval.service';
import { eq, and, desc } from 'drizzle-orm';

// ============================================================================
// Types
// ============================================================================

export type AgentType = 
  | 'data_quality_sentinel'
  | 'schema_drift_detector'
  | 'lineage_analyzer'
  | 'naming_validator';

export type ConfidenceLevel = 'high' | 'medium' | 'low';
export type RiskLevel = 'critical' | 'high' | 'medium' | 'low' | 'minimal';
export type SuggestedAction = 'create' | 'update' | 'delete' | 'flag' | 'investigate';

export interface CreateAgentProposalInput {
  tenantId: string;
  
  // What entity is affected
  entityType: 'BUSINESS_RULE' | 'GLOBAL_METADATA' | 'GLOSSARY' | 'KPI';
  entityId?: string;
  entityKey?: string;
  
  // Agent metadata
  agentType: AgentType;
  agentVersion: string;
  
  // Proposal details
  confidence: ConfidenceLevel;
  confidenceScore?: number;
  reasoning: string;
  evidence: AgentEvidence;
  
  // Risk assessment
  riskLevel: RiskLevel;
  potentialImpact?: string;
  
  // Action
  suggestedAction: SuggestedAction;
  alternativeActions?: string[];
  
  // The actual change payload
  payload: unknown;
  currentState?: unknown;
  
  // Governance
  tier: 'tier1' | 'tier2' | 'tier3' | 'tier4' | 'tier5';
  requiredApprovalRole?: string;
}

export interface AgentProposalWithApproval {
  proposal: typeof mdmAgentProposal.$inferSelect;
  approval: typeof mdmApproval.$inferSelect;
}

// ============================================================================
// Confidence to Governance Mapping
// ============================================================================

/**
 * Determine required approval role based on confidence and risk
 */
function determineRequiredRole(
  confidence: ConfidenceLevel,
  riskLevel: RiskLevel,
  tier: string,
): string {
  // Critical risk always requires kernel_architect
  if (riskLevel === 'critical') {
    return 'kernel_architect';
  }

  // High risk or tier1 requires metadata_steward
  if (riskLevel === 'high' || tier === 'tier1') {
    return 'metadata_steward';
  }

  // Low confidence requires more scrutiny
  if (confidence === 'low') {
    return 'metadata_steward';
  }

  // Medium confidence + medium risk = business_admin
  if (confidence === 'medium' || riskLevel === 'medium') {
    return 'business_admin';
  }

  // High confidence + low risk = can be lighter approval
  return 'business_admin';
}

/**
 * Determine lane based on confidence and tier
 */
function determineLane(
  confidence: ConfidenceLevel,
  tier: string,
): 'kernel' | 'governed' | 'draft' {
  // Tier1 always goes to kernel
  if (tier === 'tier1') {
    return 'kernel';
  }

  // Low confidence goes to draft for review
  if (confidence === 'low') {
    return 'draft';
  }

  // Everything else is governed
  return 'governed';
}

// ============================================================================
// Core Functions
// ============================================================================

/**
 * Create an agent proposal with associated approval request
 */
export async function createAgentProposal(
  input: CreateAgentProposalInput,
): Promise<AgentProposalWithApproval> {
  const requiredRole = input.requiredApprovalRole ?? determineRequiredRole(
    input.confidence,
    input.riskLevel,
    input.tier,
  );

  const lane = determineLane(input.confidence, input.tier);

  // 1. Create approval request
  const approval = await approvalService.createRequest({
    tenantId: input.tenantId,
    entityType: input.entityType,
    entityId: input.entityId,
    entityKey: input.entityKey,
    tier: input.tier,
    lane,
    payload: input.payload,
    currentState: input.currentState,
    requestedBy: `agent:${input.agentType}:${input.agentVersion}`,
    requiredRole,
  });

  // 2. Create agent proposal metadata
  const [proposal] = await db
    .insert(mdmAgentProposal)
    .values({
      tenantId: input.tenantId,
      approvalId: approval.id!,
      agentType: input.agentType,
      agentVersion: input.agentVersion,
      confidence: input.confidence,
      confidenceScore: input.confidenceScore?.toString(),
      reasoning: input.reasoning,
      evidence: input.evidence,
      riskLevel: input.riskLevel,
      potentialImpact: input.potentialImpact,
      suggestedAction: input.suggestedAction,
      alternativeActions: input.alternativeActions,
    })
    .returning();

  // 3. Get full approval record
  const [fullApproval] = await db
    .select()
    .from(mdmApproval)
    .where(eq(mdmApproval.id, approval.id!))
    .limit(1);

  return {
    proposal,
    approval: fullApproval,
  };
}

/**
 * List agent proposals for a tenant
 */
export async function listAgentProposals(
  tenantId: string,
  filters?: {
    agentType?: AgentType;
    confidence?: ConfidenceLevel;
    riskLevel?: RiskLevel;
    status?: 'pending' | 'approved' | 'rejected';
  },
): Promise<AgentProposalWithApproval[]> {
  const proposals = await db
    .select()
    .from(mdmAgentProposal)
    .innerJoin(mdmApproval, eq(mdmAgentProposal.approvalId, mdmApproval.id))
    .where(eq(mdmAgentProposal.tenantId, tenantId))
    .orderBy(desc(mdmAgentProposal.createdAt));

  let filtered = proposals;

  if (filters?.agentType) {
    filtered = filtered.filter(p => p.mdm_agent_proposal.agentType === filters.agentType);
  }
  if (filters?.confidence) {
    filtered = filtered.filter(p => p.mdm_agent_proposal.confidence === filters.confidence);
  }
  if (filters?.riskLevel) {
    filtered = filtered.filter(p => p.mdm_agent_proposal.riskLevel === filters.riskLevel);
  }
  if (filters?.status) {
    filtered = filtered.filter(p => p.mdm_approval.status === filters.status);
  }

  return filtered.map(p => ({
    proposal: p.mdm_agent_proposal,
    approval: p.mdm_approval,
  }));
}

/**
 * Record human feedback on a proposal
 */
export async function recordFeedback(
  proposalId: string,
  feedback: {
    humanFeedback: string;
    wasHelpful: boolean;
  },
): Promise<void> {
  await db
    .update(mdmAgentProposal)
    .set({
      humanFeedback: feedback.humanFeedback,
      wasHelpful: feedback.wasHelpful,
      reviewedAt: new Date(),
    })
    .where(eq(mdmAgentProposal.id, proposalId));
}

/**
 * Get proposal statistics for dashboard
 */
export async function getProposalStats(tenantId: string) {
  const proposals = await db
    .select()
    .from(mdmAgentProposal)
    .innerJoin(mdmApproval, eq(mdmAgentProposal.approvalId, mdmApproval.id))
    .where(eq(mdmAgentProposal.tenantId, tenantId));

  const total = proposals.length;
  const pending = proposals.filter(p => p.mdm_approval.status === 'pending').length;
  const approved = proposals.filter(p => p.mdm_approval.status === 'approved').length;
  const rejected = proposals.filter(p => p.mdm_approval.status === 'rejected').length;

  const byAgent = proposals.reduce((acc, p) => {
    const agent = p.mdm_agent_proposal.agentType;
    acc[agent] = (acc[agent] ?? 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const byConfidence = proposals.reduce((acc, p) => {
    const conf = p.mdm_agent_proposal.confidence;
    acc[conf] = (acc[conf] ?? 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const helpful = proposals.filter(p => p.mdm_agent_proposal.wasHelpful === true).length;
  const notHelpful = proposals.filter(p => p.mdm_agent_proposal.wasHelpful === false).length;
  const helpfulRate = (helpful + notHelpful) > 0 
    ? Math.round((helpful / (helpful + notHelpful)) * 100) 
    : 0;

  return {
    total,
    pending,
    approved,
    rejected,
    approvalRate: total > 0 ? Math.round((approved / total) * 100) : 0,
    byAgent,
    byConfidence,
    feedbackStats: {
      helpful,
      notHelpful,
      helpfulRate,
    },
  };
}

