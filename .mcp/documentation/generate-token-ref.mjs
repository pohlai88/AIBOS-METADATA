#!/usr/bin/env node
// Generate token reference using semantic parsing
// Simulates the update_token_reference tool

import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const workspaceRoot = path.resolve(__dirname, "../../");
const sourcePath = path.resolve(
  workspaceRoot,
  "packages/ui/src/design/globals.css"
);
const outputPath = path.resolve(
  workspaceRoot,
  "docs/09-reference/tokens/auto/tokens-reference.md"
);
const backupDir = path.resolve(workspaceRoot, "docs/.mcp-backups");

// Semantic token parsing (from server.mjs)
function parseTokenSemantically(tokenName, tokenValue) {
  const categories = {
    colors: {
      patterns: [
        /^color-/,
        /^bg-/,
        /^border-/,
        /^ring-/,
        /-color$/,
        /^brand-/,
        /^semantic-/,
      ],
      subcategories: {
        brand: /^brand-/,
        semantic: /^semantic-/,
        safe: /-safe$/,
        dark: /-dark$/,
        light: /-light$/,
      },
    },
    spacing: {
      patterns: [
        /^spacing-/,
        /^gap-/,
        /^padding-/,
        /^margin-/,
        /^inset-/,
        /-spacing$/,
      ],
    },
    typography: {
      patterns: [
        /^font-/,
        /^text-/,
        /^line-height-/,
        /^letter-spacing-/,
        /-font$/,
        /-size$/,
      ],
    },
    layout: {
      patterns: [
        /^layout-/,
        /^container-/,
        /^grid-/,
        /^flex-/,
        /^sidebar-/,
        /^topbar-/,
      ],
    },
    effects: {
      patterns: [/^shadow-/, /^blur-/, /^opacity-/, /^radius-/],
    },
  };

  for (const [category, config] of Object.entries(categories)) {
    for (const pattern of config.patterns) {
      if (pattern.test(tokenName)) {
        const result = {
          category,
          tokenName,
          tokenValue,
        };

        if (config.subcategories) {
          for (const [subcat, subPattern] of Object.entries(
            config.subcategories
          )) {
            if (subPattern.test(tokenName)) {
              result.subcategory = subcat;
              break;
            }
          }
        }

        return result;
      }
    }
  }

  return {
    category: "other",
    tokenName,
    tokenValue,
  };
}

async function generateTokenReference() {
  console.log("ðŸŽ¨ Generating Token Reference Documentation\n");
  console.log(`Source: ${sourcePath}`);
  console.log(`Target: ${outputPath}\n`);

  // Create backup if file exists
  let backup = null;
  try {
    await fs.stat(outputPath);
    const content = await fs.readFile(outputPath, "utf-8");
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const hash = content.substring(0, 8).replace(/[^a-zA-Z0-9]/g, "");
    const backupFileName = `tokens-reference.${timestamp}.${hash}.md`;
    const backupPath = path.join(backupDir, backupFileName);

    await fs.mkdir(backupDir, { recursive: true });
    await fs.writeFile(backupPath, content, "utf-8");
    backup = backupPath;
    console.log(`âœ… Backup created: ${backupPath}\n`);
  } catch (error) {
    // File doesn't exist, no backup needed
  }

  // Read globals.css
  const cssContent = await fs.readFile(sourcePath, "utf-8");

  // Extract CSS variables with semantic parsing
  const tokenRegex = /--([a-z0-9-]+):\s*([^;]+);/gi;
  const tokens = [];
  let match;

  while ((match = tokenRegex.exec(cssContent)) !== null) {
    const parsed = parseTokenSemantically(match[1], match[2].trim());
    tokens.push(parsed);
  }

  // Remove duplicates (keep first occurrence)
  const uniqueTokens = [];
  const seen = new Set();
  for (const token of tokens) {
    const key = token.tokenName;
    if (!seen.has(key)) {
      seen.add(key);
      uniqueTokens.push(token);
    }
  }

  // Group tokens by category (semantic)
  const categories = {};
  for (const token of uniqueTokens) {
    if (!categories[token.category]) {
      categories[token.category] = [];
    }
    categories[token.category].push(token);
  }

  // Generate markdown
  let markdown = `# Design Tokens Reference\n\n`;
  markdown += `> **Auto-generated from \`globals.css\`**\n`;
  markdown += `> **Last updated:** ${new Date().toISOString()}\n`;
  markdown += `> **âš ï¸ MCP-only file - Do not edit manually**\n\n`;
  markdown += `This file is automatically generated by the Documentation MCP server.\n\n`;
  markdown += `**Total tokens:** ${uniqueTokens.length}\n\n`;

  // Generate sections for each category
  const categoryOrder = [
    "colors",
    "typography",
    "spacing",
    "layout",
    "effects",
    "other",
  ];

  for (const category of categoryOrder) {
    if (categories[category] && categories[category].length > 0) {
      const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
      markdown += `## ${categoryName}\n\n`;
      markdown += `| Token | Value | Subcategory |\n`;
      markdown += `|-------|-------|-------------|\n`;

      // Sort tokens by name
      const sortedTokens = categories[category].sort((a, b) =>
        a.tokenName.localeCompare(b.tokenName)
      );

      for (const token of sortedTokens) {
        const subcat = token.subcategory || "-";
        const value =
          token.tokenValue.length > 50
            ? token.tokenValue.substring(0, 47) + "..."
            : token.tokenValue;
        markdown += `| \`--${token.tokenName}\` | \`${value}\` | ${subcat} |\n`;
      }
      markdown += `\n`;
    }
  }

  // Ensure output directory exists
  await fs.mkdir(path.dirname(outputPath), { recursive: true });

  // Write file
  await fs.writeFile(outputPath, markdown, "utf-8");

  console.log("âœ… Token reference generated successfully!");
  console.log(`   Output: ${outputPath}`);
  console.log(`   Tokens: ${uniqueTokens.length}`);
  console.log(`   Categories: ${Object.keys(categories).join(", ")}`);
  if (backup) {
    console.log(`   Backup: ${backup}`);
  }
  console.log("\nðŸ“Š Category Breakdown:");
  for (const [category, tokens] of Object.entries(categories)) {
    console.log(`   - ${category}: ${tokens.length} tokens`);
  }
}

generateTokenReference().catch(console.error);
